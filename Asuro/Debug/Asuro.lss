
Asuro.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008ec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000120  00800060  000008ec  00000980  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00800180  00800180  00000aa0  2**0
                  ALLOC
  3 .stab         00000954  00000000  00000000  00000aa0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000183  00000000  00000000  000013f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00001577  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000001d0  00000000  00000000  000015a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000009a3  00000000  00000000  00001776  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005af  00000000  00000000  00002119  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000a6d  00000000  00000000  000026c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000454  00000000  00000000  00003138  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002d8  00000000  00000000  0000358c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000762  00000000  00000000  00003864  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000120  00000000  00000000  00003fc6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
* /return    uint16 Wert des ADCs
*
*
************************************************************************/
uint16_t get_od_adc(char side)
{
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	2c c0       	rjmp	.+88     	; 0x5c <__bad_interrupt>
   4:	3f c3       	rjmp	.+1662   	; 0x684 <__vector_2>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
    PORTD |= ( 1 << PD7);               // PD7 auf HIGH -> keine LED Steuerung
   c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	8f c3       	rjmp	.+1822   	; 0x732 <__vector_9>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	22 c0       	rjmp	.+68     	; 0x5c <__bad_interrupt>
  18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
  1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
    
    
    if( side == _RIGHT)                 // aktivieren des rechten ADC
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
    {
    ADMUX &= ~( 1 << MUX0);
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	11 e0       	ldi	r17, 0x01	; 1
  34:	a0 e6       	ldi	r26, 0x60	; 96
    ADMUX &= ~( 1 << MUX1);
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	ec ee       	ldi	r30, 0xEC	; 236
  3a:	f8 e0       	ldi	r31, 0x08	; 8
  3c:	02 c0       	rjmp	.+4      	; 0x42 <__SREG__+0x3>
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0
  42:	a0 38       	cpi	r26, 0x80	; 128
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <__SP_H__>

00000048 <__do_clear_bss>:
    ADMUX &= ~( 1 << MUX2);
  48:	21 e0       	ldi	r18, 0x01	; 1
  4a:	a0 e8       	ldi	r26, 0x80	; 128
  4c:	b1 e0       	ldi	r27, 0x01	; 1
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
  50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
  52:	a2 38       	cpi	r26, 0x82	; 130
  54:	b2 07       	cpc	r27, r18
  56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
  58:	36 d0       	rcall	.+108    	; 0xc6 <main>
    ADMUX &= ~( 1 << MUX3);
  5a:	46 c4       	rjmp	.+2188   	; 0x8e8 <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <init_adc>:
  5e:	cf 93       	push	r28
  60:	df 93       	push	r29
  62:	cd b7       	in	r28, 0x3d	; 61
  64:	de b7       	in	r29, 0x3e	; 62
  66:	87 e2       	ldi	r24, 0x27	; 39
  68:	90 e0       	ldi	r25, 0x00	; 0
  6a:	27 e2       	ldi	r18, 0x27	; 39
  6c:	30 e0       	ldi	r19, 0x00	; 0
    }
    
    else if ( side == _LEFT)            // aktivieren des linken ADC
  6e:	f9 01       	movw	r30, r18
  70:	20 81       	ld	r18, Z
  72:	20 64       	ori	r18, 0x40	; 64
    {
    ADMUX |= ( 1 << MUX0);
  74:	fc 01       	movw	r30, r24
  76:	20 83       	st	Z, r18
  78:	86 e2       	ldi	r24, 0x26	; 38
  7a:	90 e0       	ldi	r25, 0x00	; 0
  7c:	26 e2       	ldi	r18, 0x26	; 38
  7e:	30 e0       	ldi	r19, 0x00	; 0
  80:	f9 01       	movw	r30, r18
  82:	20 81       	ld	r18, Z
  84:	20 68       	ori	r18, 0x80	; 128
    ADMUX &= ~( 1 << MUX1);
  86:	fc 01       	movw	r30, r24
  88:	20 83       	st	Z, r18
  8a:	86 e2       	ldi	r24, 0x26	; 38
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	26 e2       	ldi	r18, 0x26	; 38
  90:	30 e0       	ldi	r19, 0x00	; 0
  92:	f9 01       	movw	r30, r18
  94:	20 81       	ld	r18, Z
  96:	25 60       	ori	r18, 0x05	; 5
    ADMUX &= ~( 1 << MUX2);
  98:	fc 01       	movw	r30, r24
  9a:	20 83       	st	Z, r18
  9c:	86 e2       	ldi	r24, 0x26	; 38
  9e:	90 e0       	ldi	r25, 0x00	; 0
  a0:	26 e2       	ldi	r18, 0x26	; 38
  a2:	30 e0       	ldi	r19, 0x00	; 0
  a4:	f9 01       	movw	r30, r18
  a6:	20 81       	ld	r18, Z
  a8:	20 64       	ori	r18, 0x40	; 64
    ADMUX &= ~( 1 << MUX3);        
  aa:	fc 01       	movw	r30, r24
  ac:	20 83       	st	Z, r18
  ae:	00 00       	nop
  b0:	84 e2       	ldi	r24, 0x24	; 36
  b2:	90 e0       	ldi	r25, 0x00	; 0
  b4:	fc 01       	movw	r30, r24
  b6:	80 81       	ld	r24, Z
  b8:	91 81       	ldd	r25, Z+1	; 0x01
  ba:	82 e6       	ldi	r24, 0x62	; 98
    }      
      
    ADCSRA |= ( 1 << ADSC);             // Starte ADC Messung    
  bc:	90 e0       	ldi	r25, 0x00	; 0
  be:	90 d3       	rcall	.+1824   	; 0x7e0 <uart_puts>
  c0:	df 91       	pop	r29
  c2:	cf 91       	pop	r28
  c4:	08 95       	ret

000000c6 <main>:
  c6:	cf 93       	push	r28
  c8:	df 93       	push	r29
  ca:	cd b7       	in	r28, 0x3d	; 61
  cc:	de b7       	in	r29, 0x3e	; 62
    
    while( ADSC == 1)                   // Warte bis ADC-Messung beendet
  ce:	43 d3       	rcall	.+1670   	; 0x756 <init_uart>
    {
        //wait
    }
        
    return ADC;                         // gib ADC Wert zurück
  d0:	c1 d1       	rcall	.+898    	; 0x454 <init_led>
  d2:	01 d1       	rcall	.+514    	; 0x2d6 <init_motor>
  d4:	c4 df       	rcall	.-120    	; 0x5e <init_adc>
  d6:	11 d3       	rcall	.+1570   	; 0x6fa <init_timer>
  d8:	0e d0       	rcall	.+28     	; 0xf6 <init_line>
}
  da:	60 d2       	rcall	.+1216   	; 0x59c <init_switch>
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	e8 d1       	rcall	.+976    	; 0x4b0 <status_led>
  e0:	81 e0       	ldi	r24, 0x01	; 1
    init_timer();                           // initialisiere Timer
    init_line();                            // initialisiere Linienerkennung
    init_switch();                          // initialisiere Taster
    
    status_led( _GREEN);                    
    line_led(_ON);
  e2:	35 d2       	rcall	.+1130   	; 0x54e <line_led>
    uart_puts("all inits done..." _CR);
  e4:	85 e7       	ldi	r24, 0x75	; 117
  e6:	90 e0       	ldi	r25, 0x00	; 0
  e8:	7b d3       	rcall	.+1782   	; 0x7e0 <uart_puts>
    sei();                                  // aktiviere globale Interrupts
  ea:	78 94       	sei
    
    motor_dir(_FWD, _FWD);
  ec:	61 e0       	ldi	r22, 0x01	; 1
  ee:	81 e0       	ldi	r24, 0x01	; 1
  f0:	3b d1       	rcall	.+630    	; 0x368 <motor_dir>
  //  motor_pwr(255, 255);
         
    while(1)
    {

      follow_line();
  f2:	95 d0       	rcall	.+298    	; 0x21e <follow_line>

    }//while(1)
  f4:	fe cf       	rjmp	.-4      	; 0xf2 <main+0x2c>

000000f6 <init_line>:
*
* /return   none
*
************************************************************************/
void init_line(void)
{
  f6:	cf 93       	push	r28
  f8:	df 93       	push	r29
  fa:	cd b7       	in	r28, 0x3d	; 61
  fc:	de b7       	in	r29, 0x3e	; 62
    DDRC &= ~( 1 << PC3);                   // Pin als Eingang
  fe:	84 e3       	ldi	r24, 0x34	; 52
 100:	90 e0       	ldi	r25, 0x00	; 0
 102:	24 e3       	ldi	r18, 0x34	; 52
 104:	30 e0       	ldi	r19, 0x00	; 0
 106:	f9 01       	movw	r30, r18
 108:	20 81       	ld	r18, Z
 10a:	27 7f       	andi	r18, 0xF7	; 247
 10c:	fc 01       	movw	r30, r24
 10e:	20 83       	st	Z, r18
    DDRC &= ~( 1 << PC2);                   // Pin als Eingang
 110:	84 e3       	ldi	r24, 0x34	; 52
 112:	90 e0       	ldi	r25, 0x00	; 0
 114:	24 e3       	ldi	r18, 0x34	; 52
 116:	30 e0       	ldi	r19, 0x00	; 0
 118:	f9 01       	movw	r30, r18
 11a:	20 81       	ld	r18, Z
 11c:	2b 7f       	andi	r18, 0xFB	; 251
 11e:	fc 01       	movw	r30, r24
 120:	20 83       	st	Z, r18

    uart_puts("line init done...");
 122:	89 e8       	ldi	r24, 0x89	; 137
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	5c d3       	rcall	.+1720   	; 0x7e0 <uart_puts>
    uart_puts(_CR);
 128:	8b e9       	ldi	r24, 0x9B	; 155
 12a:	90 e0       	ldi	r25, 0x00	; 0
 12c:	59 d3       	rcall	.+1714   	; 0x7e0 <uart_puts>
}
 12e:	df 91       	pop	r29
 130:	cf 91       	pop	r28
 132:	08 95       	ret

00000134 <get_line_adc>:
*           ...
*           65536   max. hell
*
************************************************************************/
uint16_t get_line_adc(char side)
{    
 134:	cf 93       	push	r28
 136:	df 93       	push	r29
 138:	00 d0       	rcall	.+0      	; 0x13a <get_line_adc+0x6>
 13a:	cd b7       	in	r28, 0x3d	; 61
 13c:	de b7       	in	r29, 0x3e	; 62
 13e:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t i;

    for ( i=0; i<255; i++)
 140:	19 82       	std	Y+1, r1	; 0x01
 142:	03 c0       	rjmp	.+6      	; 0x14a <get_line_adc+0x16>
 144:	89 81       	ldd	r24, Y+1	; 0x01
 146:	8f 5f       	subi	r24, 0xFF	; 255
 148:	89 83       	std	Y+1, r24	; 0x01
 14a:	89 81       	ldd	r24, Y+1	; 0x01
 14c:	8f 3f       	cpi	r24, 0xFF	; 255
 14e:	d1 f7       	brne	.-12     	; 0x144 <get_line_adc+0x10>
    {
        //Warteschleife für Kanalwechsel
    }

    if (side == _LEFT)                       // Auswahl ADC für den linken Liniensensor
 150:	8a 81       	ldd	r24, Y+2	; 0x02
 152:	88 23       	and	r24, r24
 154:	29 f5       	brne	.+74     	; 0x1a0 <get_line_adc+0x6c>
    {
        ADMUX |=  ( 1 << MUX0);
 156:	87 e2       	ldi	r24, 0x27	; 39
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	27 e2       	ldi	r18, 0x27	; 39
 15c:	30 e0       	ldi	r19, 0x00	; 0
 15e:	f9 01       	movw	r30, r18
 160:	20 81       	ld	r18, Z
 162:	21 60       	ori	r18, 0x01	; 1
 164:	fc 01       	movw	r30, r24
 166:	20 83       	st	Z, r18
        ADMUX |=  ( 1 << MUX1);
 168:	87 e2       	ldi	r24, 0x27	; 39
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	27 e2       	ldi	r18, 0x27	; 39
 16e:	30 e0       	ldi	r19, 0x00	; 0
 170:	f9 01       	movw	r30, r18
 172:	20 81       	ld	r18, Z
 174:	22 60       	ori	r18, 0x02	; 2
 176:	fc 01       	movw	r30, r24
 178:	20 83       	st	Z, r18
        ADMUX &= ~( 1 << MUX2);
 17a:	87 e2       	ldi	r24, 0x27	; 39
 17c:	90 e0       	ldi	r25, 0x00	; 0
 17e:	27 e2       	ldi	r18, 0x27	; 39
 180:	30 e0       	ldi	r19, 0x00	; 0
 182:	f9 01       	movw	r30, r18
 184:	20 81       	ld	r18, Z
 186:	2b 7f       	andi	r18, 0xFB	; 251
 188:	fc 01       	movw	r30, r24
 18a:	20 83       	st	Z, r18
        ADMUX &= ~( 1 << MUX3);
 18c:	87 e2       	ldi	r24, 0x27	; 39
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	27 e2       	ldi	r18, 0x27	; 39
 192:	30 e0       	ldi	r19, 0x00	; 0
 194:	f9 01       	movw	r30, r18
 196:	20 81       	ld	r18, Z
 198:	27 7f       	andi	r18, 0xF7	; 247
 19a:	fc 01       	movw	r30, r24
 19c:	20 83       	st	Z, r18
 19e:	2b c0       	rjmp	.+86     	; 0x1f6 <get_line_adc+0xc2>
    }
    
    else if (side == _RIGHT)                 // Auswahl ADC für den rechten Liniensensor
 1a0:	8a 81       	ldd	r24, Y+2	; 0x02
 1a2:	81 30       	cpi	r24, 0x01	; 1
 1a4:	29 f5       	brne	.+74     	; 0x1f0 <get_line_adc+0xbc>
    {
        ADMUX &= ~( 1 << MUX0);
 1a6:	87 e2       	ldi	r24, 0x27	; 39
 1a8:	90 e0       	ldi	r25, 0x00	; 0
 1aa:	27 e2       	ldi	r18, 0x27	; 39
 1ac:	30 e0       	ldi	r19, 0x00	; 0
 1ae:	f9 01       	movw	r30, r18
 1b0:	20 81       	ld	r18, Z
 1b2:	2e 7f       	andi	r18, 0xFE	; 254
 1b4:	fc 01       	movw	r30, r24
 1b6:	20 83       	st	Z, r18
        ADMUX |=  ( 1 << MUX1);
 1b8:	87 e2       	ldi	r24, 0x27	; 39
 1ba:	90 e0       	ldi	r25, 0x00	; 0
 1bc:	27 e2       	ldi	r18, 0x27	; 39
 1be:	30 e0       	ldi	r19, 0x00	; 0
 1c0:	f9 01       	movw	r30, r18
 1c2:	20 81       	ld	r18, Z
 1c4:	22 60       	ori	r18, 0x02	; 2
 1c6:	fc 01       	movw	r30, r24
 1c8:	20 83       	st	Z, r18
        ADMUX &= ~( 1 << MUX2);
 1ca:	87 e2       	ldi	r24, 0x27	; 39
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	27 e2       	ldi	r18, 0x27	; 39
 1d0:	30 e0       	ldi	r19, 0x00	; 0
 1d2:	f9 01       	movw	r30, r18
 1d4:	20 81       	ld	r18, Z
 1d6:	2b 7f       	andi	r18, 0xFB	; 251
 1d8:	fc 01       	movw	r30, r24
 1da:	20 83       	st	Z, r18
        ADMUX &= ~( 1 << MUX3);
 1dc:	87 e2       	ldi	r24, 0x27	; 39
 1de:	90 e0       	ldi	r25, 0x00	; 0
 1e0:	27 e2       	ldi	r18, 0x27	; 39
 1e2:	30 e0       	ldi	r19, 0x00	; 0
 1e4:	f9 01       	movw	r30, r18
 1e6:	20 81       	ld	r18, Z
 1e8:	27 7f       	andi	r18, 0xF7	; 247
 1ea:	fc 01       	movw	r30, r24
 1ec:	20 83       	st	Z, r18
 1ee:	03 c0       	rjmp	.+6      	; 0x1f6 <get_line_adc+0xc2>
    }

    else                                    // Ungültige Auswahl
    {
        uart_puts("kein gültiger ADC Kanal in get_line_adc()");
 1f0:	8e e9       	ldi	r24, 0x9E	; 158
 1f2:	90 e0       	ldi	r25, 0x00	; 0
 1f4:	f5 d2       	rcall	.+1514   	; 0x7e0 <uart_puts>
    }



    ADCSRA |= ( 1 << ADSC);                 // Starte ADC Messung
 1f6:	86 e2       	ldi	r24, 0x26	; 38
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	26 e2       	ldi	r18, 0x26	; 38
 1fc:	30 e0       	ldi	r19, 0x00	; 0
 1fe:	f9 01       	movw	r30, r18
 200:	20 81       	ld	r18, Z
 202:	20 64       	ori	r18, 0x40	; 64
 204:	fc 01       	movw	r30, r24
 206:	20 83       	st	Z, r18
            
    while( ADSC == 1)                       // Warte bis ADC-Messung beendet
 208:	00 00       	nop
    {
        //wait
    }
        
    return ADC;                             // gib ADC Wert zurück
 20a:	84 e2       	ldi	r24, 0x24	; 36
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	fc 01       	movw	r30, r24
 210:	80 81       	ld	r24, Z
 212:	91 81       	ldd	r25, Z+1	; 0x01
 214:	0f 90       	pop	r0
 216:	0f 90       	pop	r0
 218:	df 91       	pop	r29
 21a:	cf 91       	pop	r28
 21c:	08 95       	ret

0000021e <follow_line>:
#define _COR_LEVEL1     20



 void follow_line(void)
 {
 21e:	0f 93       	push	r16
 220:	1f 93       	push	r17
 222:	cf 93       	push	r28
 224:	df 93       	push	r29
 226:	cd b7       	in	r28, 0x3d	; 61
 228:	de b7       	in	r29, 0x3e	; 62
     line_diff = get_line_adc(_LEFT) - get_line_adc(_RIGHT);
 22a:	80 e0       	ldi	r24, 0x00	; 0
 22c:	83 df       	rcall	.-250    	; 0x134 <get_line_adc>
 22e:	8c 01       	movw	r16, r24
 230:	81 e0       	ldi	r24, 0x01	; 1
 232:	80 df       	rcall	.-256    	; 0x134 <get_line_adc>
 234:	98 01       	movw	r18, r16
 236:	28 1b       	sub	r18, r24
 238:	39 0b       	sbc	r19, r25
 23a:	c9 01       	movw	r24, r18
 23c:	90 93 81 01 	sts	0x0181, r25
 240:	80 93 80 01 	sts	0x0180, r24
     
     if ( (line_diff > 15) && (pwr_left > (255-_COR_LEVEL1)) )
 244:	80 91 80 01 	lds	r24, 0x0180
 248:	90 91 81 01 	lds	r25, 0x0181
 24c:	80 31       	cpi	r24, 0x10	; 16
 24e:	91 05       	cpc	r25, r1
 250:	6c f0       	brlt	.+26     	; 0x26c <follow_line+0x4e>
 252:	80 91 60 00 	lds	r24, 0x0060
 256:	8c 3e       	cpi	r24, 0xEC	; 236
 258:	48 f0       	brcs	.+18     	; 0x26c <follow_line+0x4e>
     {
      //  uart_puts("15");
         pwr_left -= _COR_LEVEL1;
 25a:	80 91 60 00 	lds	r24, 0x0060
 25e:	84 51       	subi	r24, 0x14	; 20
 260:	80 93 60 00 	sts	0x0060, r24
         pwr_right = 255;
 264:	8f ef       	ldi	r24, 0xFF	; 255
 266:	80 93 61 00 	sts	0x0061, r24
 26a:	18 c0       	rjmp	.+48     	; 0x29c <follow_line+0x7e>
     }

     else if ( (line_diff < -15) && (pwr_right > (255-_COR_LEVEL1)) )
 26c:	80 91 80 01 	lds	r24, 0x0180
 270:	90 91 81 01 	lds	r25, 0x0181
 274:	81 3f       	cpi	r24, 0xF1	; 241
 276:	3f ef       	ldi	r19, 0xFF	; 255
 278:	93 07       	cpc	r25, r19
 27a:	6c f4       	brge	.+26     	; 0x296 <follow_line+0x78>
 27c:	80 91 61 00 	lds	r24, 0x0061
 280:	8c 3e       	cpi	r24, 0xEC	; 236
 282:	48 f0       	brcs	.+18     	; 0x296 <follow_line+0x78>
     {
       // uart_puts("-15");
         pwr_left = 255;
 284:	8f ef       	ldi	r24, 0xFF	; 255
 286:	80 93 60 00 	sts	0x0060, r24
         pwr_right -= _COR_LEVEL1;
 28a:	80 91 61 00 	lds	r24, 0x0061
 28e:	84 51       	subi	r24, 0x14	; 20
 290:	80 93 61 00 	sts	0x0061, r24
 294:	03 c0       	rjmp	.+6      	; 0x29c <follow_line+0x7e>
     }

     else
     {
     uart_puts("0");
 296:	88 ec       	ldi	r24, 0xC8	; 200
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	a2 d2       	rcall	.+1348   	; 0x7e0 <uart_puts>
//          }
//      }

//          motor_pwr(pwr_left, pwr_right);
// 
          uart_puti(pwr_left);
 29c:	80 91 60 00 	lds	r24, 0x0060
 2a0:	88 2f       	mov	r24, r24
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	bd d2       	rcall	.+1402   	; 0x820 <uart_puti>
          uart_puts(";");
 2a6:	8a ec       	ldi	r24, 0xCA	; 202
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	9a d2       	rcall	.+1332   	; 0x7e0 <uart_puts>
          uart_puti(pwr_right);
 2ac:	80 91 61 00 	lds	r24, 0x0061
 2b0:	88 2f       	mov	r24, r24
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	b5 d2       	rcall	.+1386   	; 0x820 <uart_puti>
         uart_puts(";");
 2b6:	8a ec       	ldi	r24, 0xCA	; 202
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	92 d2       	rcall	.+1316   	; 0x7e0 <uart_puts>
         uart_puti(line_diff);
 2bc:	80 91 80 01 	lds	r24, 0x0180
 2c0:	90 91 81 01 	lds	r25, 0x0181
 2c4:	ad d2       	rcall	.+1370   	; 0x820 <uart_puti>
         uart_puts(_CR);
 2c6:	8c ec       	ldi	r24, 0xCC	; 204
 2c8:	90 e0       	ldi	r25, 0x00	; 0
 2ca:	8a d2       	rcall	.+1300   	; 0x7e0 <uart_puts>
 2cc:	df 91       	pop	r29
 2ce:	cf 91       	pop	r28
 2d0:	1f 91       	pop	r17
 2d2:	0f 91       	pop	r16
 2d4:	08 95       	ret

000002d6 <init_motor>:
* /return   none
*
*
************************************************************************/
void init_motor(void)
{
 2d6:	cf 93       	push	r28
 2d8:	df 93       	push	r29
 2da:	cd b7       	in	r28, 0x3d	; 61
 2dc:	de b7       	in	r29, 0x3e	; 62
    /** IOs definieren **/
    DDRD |= (1 << PD4) | (1 << PD5);                // Pins für linken Motor als Ausgänge
 2de:	81 e3       	ldi	r24, 0x31	; 49
 2e0:	90 e0       	ldi	r25, 0x00	; 0
 2e2:	21 e3       	ldi	r18, 0x31	; 49
 2e4:	30 e0       	ldi	r19, 0x00	; 0
 2e6:	f9 01       	movw	r30, r18
 2e8:	20 81       	ld	r18, Z
 2ea:	20 63       	ori	r18, 0x30	; 48
 2ec:	fc 01       	movw	r30, r24
 2ee:	20 83       	st	Z, r18
    DDRB |= (1 << PB4) | (1 << PB5);                // Pins für rechten Motor als Ausgänge
 2f0:	87 e3       	ldi	r24, 0x37	; 55
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	27 e3       	ldi	r18, 0x37	; 55
 2f6:	30 e0       	ldi	r19, 0x00	; 0
 2f8:	f9 01       	movw	r30, r18
 2fa:	20 81       	ld	r18, Z
 2fc:	20 63       	ori	r18, 0x30	; 48
 2fe:	fc 01       	movw	r30, r24
 300:	20 83       	st	Z, r18
    DDRB |= (1 << PB1) | (1 << PB2);                // PWM Pins als Ausgänge
 302:	87 e3       	ldi	r24, 0x37	; 55
 304:	90 e0       	ldi	r25, 0x00	; 0
 306:	27 e3       	ldi	r18, 0x37	; 55
 308:	30 e0       	ldi	r19, 0x00	; 0
 30a:	f9 01       	movw	r30, r18
 30c:	20 81       	ld	r18, Z
 30e:	26 60       	ori	r18, 0x06	; 6
 310:	fc 01       	movw	r30, r24
 312:	20 83       	st	Z, r18
    
    /** Motor stoppen **/
    PORTD |= (1 << PD4) | (1 << PD5);               // Ausgänge auf HIGH -> Motor blockiert
 314:	82 e3       	ldi	r24, 0x32	; 50
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	22 e3       	ldi	r18, 0x32	; 50
 31a:	30 e0       	ldi	r19, 0x00	; 0
 31c:	f9 01       	movw	r30, r18
 31e:	20 81       	ld	r18, Z
 320:	20 63       	ori	r18, 0x30	; 48
 322:	fc 01       	movw	r30, r24
 324:	20 83       	st	Z, r18
    PORTB |= (1 << PB4) | (1 << PB5);               // Ausgänge auf HIGH -> Motor blockiert
 326:	88 e3       	ldi	r24, 0x38	; 56
 328:	90 e0       	ldi	r25, 0x00	; 0
 32a:	28 e3       	ldi	r18, 0x38	; 56
 32c:	30 e0       	ldi	r19, 0x00	; 0
 32e:	f9 01       	movw	r30, r18
 330:	20 81       	ld	r18, Z
 332:	20 63       	ori	r18, 0x30	; 48
 334:	fc 01       	movw	r30, r24
 336:	20 83       	st	Z, r18
        
    /** Timer konfigurieren **/
    TCCR1A |= (1 << COM1A1) | (1 << WGM10) | (1 << COM1B1);
 338:	8f e4       	ldi	r24, 0x4F	; 79
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	2f e4       	ldi	r18, 0x4F	; 79
 33e:	30 e0       	ldi	r19, 0x00	; 0
 340:	f9 01       	movw	r30, r18
 342:	20 81       	ld	r18, Z
 344:	21 6a       	ori	r18, 0xA1	; 161
 346:	fc 01       	movw	r30, r24
 348:	20 83       	st	Z, r18
    TCCR1B |= (1 << CS11);
 34a:	8e e4       	ldi	r24, 0x4E	; 78
 34c:	90 e0       	ldi	r25, 0x00	; 0
 34e:	2e e4       	ldi	r18, 0x4E	; 78
 350:	30 e0       	ldi	r19, 0x00	; 0
 352:	f9 01       	movw	r30, r18
 354:	20 81       	ld	r18, Z
 356:	22 60       	ori	r18, 0x02	; 2
 358:	fc 01       	movw	r30, r24
 35a:	20 83       	st	Z, r18
    
    uart_puts("motor init done..." _CR);
 35c:	8f ec       	ldi	r24, 0xCF	; 207
 35e:	90 e0       	ldi	r25, 0x00	; 0
 360:	3f d2       	rcall	.+1150   	; 0x7e0 <uart_puts>
}
 362:	df 91       	pop	r29
 364:	cf 91       	pop	r28
 366:	08 95       	ret

00000368 <motor_dir>:
* /return   none
*
*
************************************************************************/
void motor_dir( char left, char right)
{
 368:	cf 93       	push	r28
 36a:	df 93       	push	r29
 36c:	00 d0       	rcall	.+0      	; 0x36e <motor_dir+0x6>
 36e:	cd b7       	in	r28, 0x3d	; 61
 370:	de b7       	in	r29, 0x3e	; 62
 372:	89 83       	std	Y+1, r24	; 0x01
 374:	6a 83       	std	Y+2, r22	; 0x02
    /** Linke Seite **/
    if ( left == _FWD)                              // Motor vorwärts
 376:	89 81       	ldd	r24, Y+1	; 0x01
 378:	81 30       	cpi	r24, 0x01	; 1
 37a:	99 f4       	brne	.+38     	; 0x3a2 <motor_dir+0x3a>
    {
        PORTD |= (1 << PD5);
 37c:	82 e3       	ldi	r24, 0x32	; 50
 37e:	90 e0       	ldi	r25, 0x00	; 0
 380:	22 e3       	ldi	r18, 0x32	; 50
 382:	30 e0       	ldi	r19, 0x00	; 0
 384:	f9 01       	movw	r30, r18
 386:	20 81       	ld	r18, Z
 388:	20 62       	ori	r18, 0x20	; 32
 38a:	fc 01       	movw	r30, r24
 38c:	20 83       	st	Z, r18
        PORTD &= ~(1 << PD4);        
 38e:	82 e3       	ldi	r24, 0x32	; 50
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	22 e3       	ldi	r18, 0x32	; 50
 394:	30 e0       	ldi	r19, 0x00	; 0
 396:	f9 01       	movw	r30, r18
 398:	20 81       	ld	r18, Z
 39a:	2f 7e       	andi	r18, 0xEF	; 239
 39c:	fc 01       	movw	r30, r24
 39e:	20 83       	st	Z, r18
 3a0:	1f c0       	rjmp	.+62     	; 0x3e0 <motor_dir+0x78>
    }
        
    else if ( left == _RWD)                         // Motor rückwärts
 3a2:	89 81       	ldd	r24, Y+1	; 0x01
 3a4:	82 30       	cpi	r24, 0x02	; 2
 3a6:	99 f4       	brne	.+38     	; 0x3ce <motor_dir+0x66>
    {
        PORTD &= ~(1 << PD5);
 3a8:	82 e3       	ldi	r24, 0x32	; 50
 3aa:	90 e0       	ldi	r25, 0x00	; 0
 3ac:	22 e3       	ldi	r18, 0x32	; 50
 3ae:	30 e0       	ldi	r19, 0x00	; 0
 3b0:	f9 01       	movw	r30, r18
 3b2:	20 81       	ld	r18, Z
 3b4:	2f 7d       	andi	r18, 0xDF	; 223
 3b6:	fc 01       	movw	r30, r24
 3b8:	20 83       	st	Z, r18
        PORTD |=  (1 << PD4);        
 3ba:	82 e3       	ldi	r24, 0x32	; 50
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	22 e3       	ldi	r18, 0x32	; 50
 3c0:	30 e0       	ldi	r19, 0x00	; 0
 3c2:	f9 01       	movw	r30, r18
 3c4:	20 81       	ld	r18, Z
 3c6:	20 61       	ori	r18, 0x10	; 16
 3c8:	fc 01       	movw	r30, r24
 3ca:	20 83       	st	Z, r18
 3cc:	09 c0       	rjmp	.+18     	; 0x3e0 <motor_dir+0x78>
    }
        
    else                                            // ungültige Auswahl
    {
    PORTD |= (1 << PD4) | (1 << PD5);               // Ausgänge auf HIGH -> Motor blockiert
 3ce:	82 e3       	ldi	r24, 0x32	; 50
 3d0:	90 e0       	ldi	r25, 0x00	; 0
 3d2:	22 e3       	ldi	r18, 0x32	; 50
 3d4:	30 e0       	ldi	r19, 0x00	; 0
 3d6:	f9 01       	movw	r30, r18
 3d8:	20 81       	ld	r18, Z
 3da:	20 63       	ori	r18, 0x30	; 48
 3dc:	fc 01       	movw	r30, r24
 3de:	20 83       	st	Z, r18
    }
    
    
    /** Rechte Seite **/
    if ( right == _FWD)                             // Motor vorwärts
 3e0:	8a 81       	ldd	r24, Y+2	; 0x02
 3e2:	81 30       	cpi	r24, 0x01	; 1
 3e4:	99 f4       	brne	.+38     	; 0x40c <motor_dir+0xa4>
    {
        PORTB |= (1 << PB5);
 3e6:	88 e3       	ldi	r24, 0x38	; 56
 3e8:	90 e0       	ldi	r25, 0x00	; 0
 3ea:	28 e3       	ldi	r18, 0x38	; 56
 3ec:	30 e0       	ldi	r19, 0x00	; 0
 3ee:	f9 01       	movw	r30, r18
 3f0:	20 81       	ld	r18, Z
 3f2:	20 62       	ori	r18, 0x20	; 32
 3f4:	fc 01       	movw	r30, r24
 3f6:	20 83       	st	Z, r18
        PORTB &= ~(1 << PB4);
 3f8:	88 e3       	ldi	r24, 0x38	; 56
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	28 e3       	ldi	r18, 0x38	; 56
 3fe:	30 e0       	ldi	r19, 0x00	; 0
 400:	f9 01       	movw	r30, r18
 402:	20 81       	ld	r18, Z
 404:	2f 7e       	andi	r18, 0xEF	; 239
 406:	fc 01       	movw	r30, r24
 408:	20 83       	st	Z, r18
 40a:	1f c0       	rjmp	.+62     	; 0x44a <motor_dir+0xe2>
    }
    
    else if ( right == _RWD)                        // Motor rückwärts
 40c:	8a 81       	ldd	r24, Y+2	; 0x02
 40e:	82 30       	cpi	r24, 0x02	; 2
 410:	99 f4       	brne	.+38     	; 0x438 <motor_dir+0xd0>
    {
        PORTB &= ~(1 << PB5);
 412:	88 e3       	ldi	r24, 0x38	; 56
 414:	90 e0       	ldi	r25, 0x00	; 0
 416:	28 e3       	ldi	r18, 0x38	; 56
 418:	30 e0       	ldi	r19, 0x00	; 0
 41a:	f9 01       	movw	r30, r18
 41c:	20 81       	ld	r18, Z
 41e:	2f 7d       	andi	r18, 0xDF	; 223
 420:	fc 01       	movw	r30, r24
 422:	20 83       	st	Z, r18
        PORTB |=  (1 << PB4);
 424:	88 e3       	ldi	r24, 0x38	; 56
 426:	90 e0       	ldi	r25, 0x00	; 0
 428:	28 e3       	ldi	r18, 0x38	; 56
 42a:	30 e0       	ldi	r19, 0x00	; 0
 42c:	f9 01       	movw	r30, r18
 42e:	20 81       	ld	r18, Z
 430:	20 61       	ori	r18, 0x10	; 16
 432:	fc 01       	movw	r30, r24
 434:	20 83       	st	Z, r18
 436:	09 c0       	rjmp	.+18     	; 0x44a <motor_dir+0xe2>
    }
    
    else                                            // ungültige Auswahl
    {
        PORTB |= (1 << PB4) | (1 << PB5);           // Ausgänge auf HIGH -> Motor blockiert
 438:	88 e3       	ldi	r24, 0x38	; 56
 43a:	90 e0       	ldi	r25, 0x00	; 0
 43c:	28 e3       	ldi	r18, 0x38	; 56
 43e:	30 e0       	ldi	r19, 0x00	; 0
 440:	f9 01       	movw	r30, r18
 442:	20 81       	ld	r18, Z
 444:	20 63       	ori	r18, 0x30	; 48
 446:	fc 01       	movw	r30, r24
 448:	20 83       	st	Z, r18
    }    
}
 44a:	0f 90       	pop	r0
 44c:	0f 90       	pop	r0
 44e:	df 91       	pop	r29
 450:	cf 91       	pop	r28
 452:	08 95       	ret

00000454 <init_led>:
* /return    none
*
*
************************************************************************/
void init_led (void)
{
 454:	cf 93       	push	r28
 456:	df 93       	push	r29
 458:	cd b7       	in	r28, 0x3d	; 61
 45a:	de b7       	in	r29, 0x3e	; 62
    DDRD |= (1 << PD7);                        // PD7 als Ausgang für Back LEDs
 45c:	81 e3       	ldi	r24, 0x31	; 49
 45e:	90 e0       	ldi	r25, 0x00	; 0
 460:	21 e3       	ldi	r18, 0x31	; 49
 462:	30 e0       	ldi	r19, 0x00	; 0
 464:	f9 01       	movw	r30, r18
 466:	20 81       	ld	r18, Z
 468:	20 68       	ori	r18, 0x80	; 128
 46a:	fc 01       	movw	r30, r24
 46c:	20 83       	st	Z, r18
    DDRD |= (1 << PD2);                        // PD2 als Ausgang für RG_LED
 46e:	81 e3       	ldi	r24, 0x31	; 49
 470:	90 e0       	ldi	r25, 0x00	; 0
 472:	21 e3       	ldi	r18, 0x31	; 49
 474:	30 e0       	ldi	r19, 0x00	; 0
 476:	f9 01       	movw	r30, r18
 478:	20 81       	ld	r18, Z
 47a:	24 60       	ori	r18, 0x04	; 4
 47c:	fc 01       	movw	r30, r24
 47e:	20 83       	st	Z, r18
    DDRB |= (1 << PB0);                        // PB0 als Ausgang für RG_LED
 480:	87 e3       	ldi	r24, 0x37	; 55
 482:	90 e0       	ldi	r25, 0x00	; 0
 484:	27 e3       	ldi	r18, 0x37	; 55
 486:	30 e0       	ldi	r19, 0x00	; 0
 488:	f9 01       	movw	r30, r18
 48a:	20 81       	ld	r18, Z
 48c:	21 60       	ori	r18, 0x01	; 1
 48e:	fc 01       	movw	r30, r24
 490:	20 83       	st	Z, r18
    DDRD |= (1 << PD6);
 492:	81 e3       	ldi	r24, 0x31	; 49
 494:	90 e0       	ldi	r25, 0x00	; 0
 496:	21 e3       	ldi	r18, 0x31	; 49
 498:	30 e0       	ldi	r19, 0x00	; 0
 49a:	f9 01       	movw	r30, r18
 49c:	20 81       	ld	r18, Z
 49e:	20 64       	ori	r18, 0x40	; 64
 4a0:	fc 01       	movw	r30, r24
 4a2:	20 83       	st	Z, r18
    
    uart_puts("led init done..." _CR);
 4a4:	84 ee       	ldi	r24, 0xE4	; 228
 4a6:	90 e0       	ldi	r25, 0x00	; 0
 4a8:	9b d1       	rcall	.+822    	; 0x7e0 <uart_puts>
}
 4aa:	df 91       	pop	r29
 4ac:	cf 91       	pop	r28
 4ae:	08 95       	ret

000004b0 <status_led>:
* /return   none
*
*
************************************************************************/
void status_led( char colour)
{
 4b0:	cf 93       	push	r28
 4b2:	df 93       	push	r29
 4b4:	1f 92       	push	r1
 4b6:	cd b7       	in	r28, 0x3d	; 61
 4b8:	de b7       	in	r29, 0x3e	; 62
 4ba:	89 83       	std	Y+1, r24	; 0x01
    if ( colour == _GREEN)
 4bc:	89 81       	ldd	r24, Y+1	; 0x01
 4be:	81 30       	cpi	r24, 0x01	; 1
 4c0:	99 f4       	brne	.+38     	; 0x4e8 <status_led+0x38>
    {
        PORTB |=  ( 1 << PB0 );
 4c2:	88 e3       	ldi	r24, 0x38	; 56
 4c4:	90 e0       	ldi	r25, 0x00	; 0
 4c6:	28 e3       	ldi	r18, 0x38	; 56
 4c8:	30 e0       	ldi	r19, 0x00	; 0
 4ca:	f9 01       	movw	r30, r18
 4cc:	20 81       	ld	r18, Z
 4ce:	21 60       	ori	r18, 0x01	; 1
 4d0:	fc 01       	movw	r30, r24
 4d2:	20 83       	st	Z, r18
        PORTD &= ~( 1 << PD2 );
 4d4:	82 e3       	ldi	r24, 0x32	; 50
 4d6:	90 e0       	ldi	r25, 0x00	; 0
 4d8:	22 e3       	ldi	r18, 0x32	; 50
 4da:	30 e0       	ldi	r19, 0x00	; 0
 4dc:	f9 01       	movw	r30, r18
 4de:	20 81       	ld	r18, Z
 4e0:	2b 7f       	andi	r18, 0xFB	; 251
 4e2:	fc 01       	movw	r30, r24
 4e4:	20 83       	st	Z, r18
 4e6:	2f c0       	rjmp	.+94     	; 0x546 <status_led+0x96>
    }
     
    else if ( colour == _RED )
 4e8:	89 81       	ldd	r24, Y+1	; 0x01
 4ea:	82 30       	cpi	r24, 0x02	; 2
 4ec:	99 f4       	brne	.+38     	; 0x514 <status_led+0x64>
    {
        PORTB &= ~( 1 << PB0 );
 4ee:	88 e3       	ldi	r24, 0x38	; 56
 4f0:	90 e0       	ldi	r25, 0x00	; 0
 4f2:	28 e3       	ldi	r18, 0x38	; 56
 4f4:	30 e0       	ldi	r19, 0x00	; 0
 4f6:	f9 01       	movw	r30, r18
 4f8:	20 81       	ld	r18, Z
 4fa:	2e 7f       	andi	r18, 0xFE	; 254
 4fc:	fc 01       	movw	r30, r24
 4fe:	20 83       	st	Z, r18
        PORTD |=  ( 1 << PD2 );
 500:	82 e3       	ldi	r24, 0x32	; 50
 502:	90 e0       	ldi	r25, 0x00	; 0
 504:	22 e3       	ldi	r18, 0x32	; 50
 506:	30 e0       	ldi	r19, 0x00	; 0
 508:	f9 01       	movw	r30, r18
 50a:	20 81       	ld	r18, Z
 50c:	24 60       	ori	r18, 0x04	; 4
 50e:	fc 01       	movw	r30, r24
 510:	20 83       	st	Z, r18
 512:	19 c0       	rjmp	.+50     	; 0x546 <status_led+0x96>
    }
     
    else if ( colour == _ORANGE )
 514:	89 81       	ldd	r24, Y+1	; 0x01
 516:	83 30       	cpi	r24, 0x03	; 3
 518:	99 f4       	brne	.+38     	; 0x540 <status_led+0x90>
    {
        PORTB |= ( 1 << PB0 );
 51a:	88 e3       	ldi	r24, 0x38	; 56
 51c:	90 e0       	ldi	r25, 0x00	; 0
 51e:	28 e3       	ldi	r18, 0x38	; 56
 520:	30 e0       	ldi	r19, 0x00	; 0
 522:	f9 01       	movw	r30, r18
 524:	20 81       	ld	r18, Z
 526:	21 60       	ori	r18, 0x01	; 1
 528:	fc 01       	movw	r30, r24
 52a:	20 83       	st	Z, r18
        PORTD |= ( 1 << PD2 );
 52c:	82 e3       	ldi	r24, 0x32	; 50
 52e:	90 e0       	ldi	r25, 0x00	; 0
 530:	22 e3       	ldi	r18, 0x32	; 50
 532:	30 e0       	ldi	r19, 0x00	; 0
 534:	f9 01       	movw	r30, r18
 536:	20 81       	ld	r18, Z
 538:	24 60       	ori	r18, 0x04	; 4
 53a:	fc 01       	movw	r30, r24
 53c:	20 83       	st	Z, r18
 53e:	03 c0       	rjmp	.+6      	; 0x546 <status_led+0x96>
    }
     
    else
    {
        uart_puts("falsche Eingabe bei status_led()");
 540:	87 ef       	ldi	r24, 0xF7	; 247
 542:	90 e0       	ldi	r25, 0x00	; 0
 544:	4d d1       	rcall	.+666    	; 0x7e0 <uart_puts>
    }     
     
}
 546:	0f 90       	pop	r0
 548:	df 91       	pop	r29
 54a:	cf 91       	pop	r28
 54c:	08 95       	ret

0000054e <line_led>:
* /return    none
*
*
************************************************************************/ 
void line_led(char status)
{
 54e:	cf 93       	push	r28
 550:	df 93       	push	r29
 552:	1f 92       	push	r1
 554:	cd b7       	in	r28, 0x3d	; 61
 556:	de b7       	in	r29, 0x3e	; 62
 558:	89 83       	std	Y+1, r24	; 0x01
    if(status == _ON)
 55a:	89 81       	ldd	r24, Y+1	; 0x01
 55c:	81 30       	cpi	r24, 0x01	; 1
 55e:	51 f4       	brne	.+20     	; 0x574 <line_led+0x26>
    {
        PORTD |= ( 1 << PD6 );
 560:	82 e3       	ldi	r24, 0x32	; 50
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	22 e3       	ldi	r18, 0x32	; 50
 566:	30 e0       	ldi	r19, 0x00	; 0
 568:	f9 01       	movw	r30, r18
 56a:	20 81       	ld	r18, Z
 56c:	20 64       	ori	r18, 0x40	; 64
 56e:	fc 01       	movw	r30, r24
 570:	20 83       	st	Z, r18
 572:	10 c0       	rjmp	.+32     	; 0x594 <line_led+0x46>
    }
    
    else if( status == _OFF)
 574:	89 81       	ldd	r24, Y+1	; 0x01
 576:	88 23       	and	r24, r24
 578:	51 f4       	brne	.+20     	; 0x58e <line_led+0x40>
    {
        PORTD &= ~( 1 << PD6);
 57a:	82 e3       	ldi	r24, 0x32	; 50
 57c:	90 e0       	ldi	r25, 0x00	; 0
 57e:	22 e3       	ldi	r18, 0x32	; 50
 580:	30 e0       	ldi	r19, 0x00	; 0
 582:	f9 01       	movw	r30, r18
 584:	20 81       	ld	r18, Z
 586:	2f 7b       	andi	r18, 0xBF	; 191
 588:	fc 01       	movw	r30, r24
 58a:	20 83       	st	Z, r18
 58c:	03 c0       	rjmp	.+6      	; 0x594 <line_led+0x46>
    }
    
    else
    {
        uart_puts("falsche Eingabe bei line_led()");
 58e:	88 e1       	ldi	r24, 0x18	; 24
 590:	91 e0       	ldi	r25, 0x01	; 1
 592:	26 d1       	rcall	.+588    	; 0x7e0 <uart_puts>
    }
 594:	0f 90       	pop	r0
 596:	df 91       	pop	r29
 598:	cf 91       	pop	r28
 59a:	08 95       	ret

0000059c <init_switch>:
 * /return  none
 *
 *
 ************************************************************************/
 void init_switch(void)
 {
 59c:	cf 93       	push	r28
 59e:	df 93       	push	r29
 5a0:	cd b7       	in	r28, 0x3d	; 61
 5a2:	de b7       	in	r29, 0x3e	; 62
    DDRC &= ~( 1 << PC4);               // PC4 als Eingang definieren (ADC4)
 5a4:	84 e3       	ldi	r24, 0x34	; 52
 5a6:	90 e0       	ldi	r25, 0x00	; 0
 5a8:	24 e3       	ldi	r18, 0x34	; 52
 5aa:	30 e0       	ldi	r19, 0x00	; 0
 5ac:	f9 01       	movw	r30, r18
 5ae:	20 81       	ld	r18, Z
 5b0:	2f 7e       	andi	r18, 0xEF	; 239
 5b2:	fc 01       	movw	r30, r24
 5b4:	20 83       	st	Z, r18
    DDRC &= ~( 1 << PD3);               // PD3 als Eingang definieren (INT1)
 5b6:	84 e3       	ldi	r24, 0x34	; 52
 5b8:	90 e0       	ldi	r25, 0x00	; 0
 5ba:	24 e3       	ldi	r18, 0x34	; 52
 5bc:	30 e0       	ldi	r19, 0x00	; 0
 5be:	f9 01       	movw	r30, r18
 5c0:	20 81       	ld	r18, Z
 5c2:	27 7f       	andi	r18, 0xF7	; 247
 5c4:	fc 01       	movw	r30, r24
 5c6:	20 83       	st	Z, r18

    /** ITN1 definieren **/
    MCUCR |=  ( 1 << ISC11);             // Interrupt bei fallender Flanke an INT1
 5c8:	85 e5       	ldi	r24, 0x55	; 85
 5ca:	90 e0       	ldi	r25, 0x00	; 0
 5cc:	25 e5       	ldi	r18, 0x55	; 85
 5ce:	30 e0       	ldi	r19, 0x00	; 0
 5d0:	f9 01       	movw	r30, r18
 5d2:	20 81       	ld	r18, Z
 5d4:	28 60       	ori	r18, 0x08	; 8
 5d6:	fc 01       	movw	r30, r24
 5d8:	20 83       	st	Z, r18
    MCUCR &= ~( 1 << ISC10);
 5da:	85 e5       	ldi	r24, 0x55	; 85
 5dc:	90 e0       	ldi	r25, 0x00	; 0
 5de:	25 e5       	ldi	r18, 0x55	; 85
 5e0:	30 e0       	ldi	r19, 0x00	; 0
 5e2:	f9 01       	movw	r30, r18
 5e4:	20 81       	ld	r18, Z
 5e6:	2b 7f       	andi	r18, 0xFB	; 251
 5e8:	fc 01       	movw	r30, r24
 5ea:	20 83       	st	Z, r18

    GICR |= ( 1 << INT1);               // Intterupt INT1 aktivieren
 5ec:	8b e5       	ldi	r24, 0x5B	; 91
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	2b e5       	ldi	r18, 0x5B	; 91
 5f2:	30 e0       	ldi	r19, 0x00	; 0
 5f4:	f9 01       	movw	r30, r18
 5f6:	20 81       	ld	r18, Z
 5f8:	20 68       	ori	r18, 0x80	; 128
 5fa:	fc 01       	movw	r30, r24
 5fc:	20 83       	st	Z, r18

    uart_puts("switch init done...");
 5fe:	87 e3       	ldi	r24, 0x37	; 55
 600:	91 e0       	ldi	r25, 0x01	; 1
 602:	ee d0       	rcall	.+476    	; 0x7e0 <uart_puts>
    uart_puts(_CR);
 604:	8b e4       	ldi	r24, 0x4B	; 75
 606:	91 e0       	ldi	r25, 0x01	; 1
 608:	eb d0       	rcall	.+470    	; 0x7e0 <uart_puts>

 }
 60a:	df 91       	pop	r29
 60c:	cf 91       	pop	r28
 60e:	08 95       	ret

00000610 <get_switch_adc>:
 * /return  ADC Wert (uint16_t)
 *
 *
 ************************************************************************/
 uint16_t get_switch_adc(void)
 {
 610:	cf 93       	push	r28
 612:	df 93       	push	r29
 614:	cd b7       	in	r28, 0x3d	; 61
 616:	de b7       	in	r29, 0x3e	; 62

    ADMUX &= ~( 1 << MUX0);
 618:	87 e2       	ldi	r24, 0x27	; 39
 61a:	90 e0       	ldi	r25, 0x00	; 0
 61c:	27 e2       	ldi	r18, 0x27	; 39
 61e:	30 e0       	ldi	r19, 0x00	; 0
 620:	f9 01       	movw	r30, r18
 622:	20 81       	ld	r18, Z
 624:	2e 7f       	andi	r18, 0xFE	; 254
 626:	fc 01       	movw	r30, r24
 628:	20 83       	st	Z, r18
    ADMUX &= ~( 1 << MUX1);
 62a:	87 e2       	ldi	r24, 0x27	; 39
 62c:	90 e0       	ldi	r25, 0x00	; 0
 62e:	27 e2       	ldi	r18, 0x27	; 39
 630:	30 e0       	ldi	r19, 0x00	; 0
 632:	f9 01       	movw	r30, r18
 634:	20 81       	ld	r18, Z
 636:	2d 7f       	andi	r18, 0xFD	; 253
 638:	fc 01       	movw	r30, r24
 63a:	20 83       	st	Z, r18
    ADMUX |=  ( 1 << MUX2);
 63c:	87 e2       	ldi	r24, 0x27	; 39
 63e:	90 e0       	ldi	r25, 0x00	; 0
 640:	27 e2       	ldi	r18, 0x27	; 39
 642:	30 e0       	ldi	r19, 0x00	; 0
 644:	f9 01       	movw	r30, r18
 646:	20 81       	ld	r18, Z
 648:	24 60       	ori	r18, 0x04	; 4
 64a:	fc 01       	movw	r30, r24
 64c:	20 83       	st	Z, r18
    ADMUX &= ~( 1 << MUX3);
 64e:	87 e2       	ldi	r24, 0x27	; 39
 650:	90 e0       	ldi	r25, 0x00	; 0
 652:	27 e2       	ldi	r18, 0x27	; 39
 654:	30 e0       	ldi	r19, 0x00	; 0
 656:	f9 01       	movw	r30, r18
 658:	20 81       	ld	r18, Z
 65a:	27 7f       	andi	r18, 0xF7	; 247
 65c:	fc 01       	movw	r30, r24
 65e:	20 83       	st	Z, r18

    ADCSRA |= ( 1 << ADSC);                 // Starte ADC Messung
 660:	86 e2       	ldi	r24, 0x26	; 38
 662:	90 e0       	ldi	r25, 0x00	; 0
 664:	26 e2       	ldi	r18, 0x26	; 38
 666:	30 e0       	ldi	r19, 0x00	; 0
 668:	f9 01       	movw	r30, r18
 66a:	20 81       	ld	r18, Z
 66c:	20 64       	ori	r18, 0x40	; 64
 66e:	fc 01       	movw	r30, r24
 670:	20 83       	st	Z, r18
    
    while( ADSC == 1)                       // Warte bis ADC-Messung beendet
 672:	00 00       	nop
    {
        //wait
    }
    
    return ADC;                             // gib ADC Wert zurück
 674:	84 e2       	ldi	r24, 0x24	; 36
 676:	90 e0       	ldi	r25, 0x00	; 0
 678:	fc 01       	movw	r30, r24
 67a:	80 81       	ld	r24, Z
 67c:	91 81       	ldd	r25, Z+1	; 0x01
 }
 67e:	df 91       	pop	r29
 680:	cf 91       	pop	r28
 682:	08 95       	ret

00000684 <__vector_2>:


 }

 ISR (INT1_vect)
 {
 684:	1f 92       	push	r1
 686:	0f 92       	push	r0
 688:	00 90 5f 00 	lds	r0, 0x005F
 68c:	0f 92       	push	r0
 68e:	11 24       	eor	r1, r1
 690:	2f 93       	push	r18
 692:	3f 93       	push	r19
 694:	4f 93       	push	r20
 696:	5f 93       	push	r21
 698:	6f 93       	push	r22
 69a:	7f 93       	push	r23
 69c:	8f 93       	push	r24
 69e:	9f 93       	push	r25
 6a0:	af 93       	push	r26
 6a2:	bf 93       	push	r27
 6a4:	ef 93       	push	r30
 6a6:	ff 93       	push	r31
 6a8:	cf 93       	push	r28
 6aa:	df 93       	push	r29
 6ac:	00 d0       	rcall	.+0      	; 0x6ae <__vector_2+0x2a>
 6ae:	cd b7       	in	r28, 0x3d	; 61
 6b0:	de b7       	in	r29, 0x3e	; 62
    //get_switch();
    uint16_t buffer2 = 0;
 6b2:	1a 82       	std	Y+2, r1	; 0x02
 6b4:	19 82       	std	Y+1, r1	; 0x01

    buffer2 = get_switch_adc();
 6b6:	ac df       	rcall	.-168    	; 0x610 <get_switch_adc>
 6b8:	9a 83       	std	Y+2, r25	; 0x02
 6ba:	89 83       	std	Y+1, r24	; 0x01
    uart_puts("switch:");
 6bc:	8e e4       	ldi	r24, 0x4E	; 78
 6be:	91 e0       	ldi	r25, 0x01	; 1
 6c0:	8f d0       	rcall	.+286    	; 0x7e0 <uart_puts>
    uart_puti(buffer2);
 6c2:	89 81       	ldd	r24, Y+1	; 0x01
 6c4:	9a 81       	ldd	r25, Y+2	; 0x02
 6c6:	ac d0       	rcall	.+344    	; 0x820 <uart_puti>
    uart_puts(_CR);
 6c8:	8b e4       	ldi	r24, 0x4B	; 75
 6ca:	91 e0       	ldi	r25, 0x01	; 1
 6cc:	89 d0       	rcall	.+274    	; 0x7e0 <uart_puts>
 
 }
 6ce:	0f 90       	pop	r0
 6d0:	0f 90       	pop	r0
 6d2:	df 91       	pop	r29
 6d4:	cf 91       	pop	r28
 6d6:	ff 91       	pop	r31
 6d8:	ef 91       	pop	r30
 6da:	bf 91       	pop	r27
 6dc:	af 91       	pop	r26
 6de:	9f 91       	pop	r25
 6e0:	8f 91       	pop	r24
 6e2:	7f 91       	pop	r23
 6e4:	6f 91       	pop	r22
 6e6:	5f 91       	pop	r21
 6e8:	4f 91       	pop	r20
 6ea:	3f 91       	pop	r19
 6ec:	2f 91       	pop	r18
 6ee:	0f 90       	pop	r0
 6f0:	00 92 5f 00 	sts	0x005F, r0
 6f4:	0f 90       	pop	r0
 6f6:	1f 90       	pop	r1
 6f8:	18 95       	reti

000006fa <init_timer>:
* /return   none
*
*
************************************************************************/
void init_timer(void)
{
 6fa:	cf 93       	push	r28
 6fc:	df 93       	push	r29
 6fe:	cd b7       	in	r28, 0x3d	; 61
 700:	de b7       	in	r29, 0x3e	; 62
    TCCR0 |=  (1 << CS02) | (1 << CS00);                //prescaler 1024
 702:	83 e5       	ldi	r24, 0x53	; 83
 704:	90 e0       	ldi	r25, 0x00	; 0
 706:	23 e5       	ldi	r18, 0x53	; 83
 708:	30 e0       	ldi	r19, 0x00	; 0
 70a:	f9 01       	movw	r30, r18
 70c:	20 81       	ld	r18, Z
 70e:	25 60       	ori	r18, 0x05	; 5
 710:	fc 01       	movw	r30, r24
 712:	20 83       	st	Z, r18
                                                        // -> 8MHz/1024= 7,8Khz ~ 128µs
    TIMSK |= (1 << TOIE0);                                // enable Timer-Overflow interrupt
 714:	89 e5       	ldi	r24, 0x59	; 89
 716:	90 e0       	ldi	r25, 0x00	; 0
 718:	29 e5       	ldi	r18, 0x59	; 89
 71a:	30 e0       	ldi	r19, 0x00	; 0
 71c:	f9 01       	movw	r30, r18
 71e:	20 81       	ld	r18, Z
 720:	21 60       	ori	r18, 0x01	; 1
 722:	fc 01       	movw	r30, r24
 724:	20 83       	st	Z, r18
                                                        
    uart_puts("timer init done..." _CR);
 726:	86 e5       	ldi	r24, 0x56	; 86
 728:	91 e0       	ldi	r25, 0x01	; 1
 72a:	5a d0       	rcall	.+180    	; 0x7e0 <uart_puts>
}
 72c:	df 91       	pop	r29
 72e:	cf 91       	pop	r28
 730:	08 95       	ret

00000732 <__vector_9>:
* /return   none
*
*
************************************************************************/
ISR (TIMER0_OVF_vect)
{
 732:	1f 92       	push	r1
 734:	0f 92       	push	r0
 736:	00 90 5f 00 	lds	r0, 0x005F
 73a:	0f 92       	push	r0
 73c:	11 24       	eor	r1, r1
 73e:	cf 93       	push	r28
 740:	df 93       	push	r29
 742:	cd b7       	in	r28, 0x3d	; 61
 744:	de b7       	in	r29, 0x3e	; 62
    //enter Code here    

}
 746:	df 91       	pop	r29
 748:	cf 91       	pop	r28
 74a:	0f 90       	pop	r0
 74c:	00 92 5f 00 	sts	0x005F, r0
 750:	0f 90       	pop	r0
 752:	1f 90       	pop	r1
 754:	18 95       	reti

00000756 <init_uart>:
* /return   none
*
*
************************************************************************/
void init_uart(void)
{
 756:	cf 93       	push	r28
 758:	df 93       	push	r29
 75a:	1f 92       	push	r1
 75c:	cd b7       	in	r28, 0x3d	; 61
 75e:	de b7       	in	r29, 0x3e	; 62
        uint8_t ubrr;
        ubrr = _FOSC/16/_BAUD-1;
 760:	8f ec       	ldi	r24, 0xCF	; 207
 762:	89 83       	std	Y+1, r24	; 0x01
        /* Set baud rate */
        UBRRH = (unsigned char)(ubrr>>8);
 764:	80 e4       	ldi	r24, 0x40	; 64
 766:	90 e0       	ldi	r25, 0x00	; 0
 768:	29 81       	ldd	r18, Y+1	; 0x01
 76a:	22 2f       	mov	r18, r18
 76c:	30 e0       	ldi	r19, 0x00	; 0
 76e:	23 2f       	mov	r18, r19
 770:	33 0f       	add	r19, r19
 772:	33 0b       	sbc	r19, r19
 774:	fc 01       	movw	r30, r24
 776:	20 83       	st	Z, r18
        UBRRL = (unsigned char)ubrr;
 778:	89 e2       	ldi	r24, 0x29	; 41
 77a:	90 e0       	ldi	r25, 0x00	; 0
 77c:	29 81       	ldd	r18, Y+1	; 0x01
 77e:	fc 01       	movw	r30, r24
 780:	20 83       	st	Z, r18
        /* Enable receiver and transmitter */
        UCSRB |= (1<<TXEN);
 782:	8a e2       	ldi	r24, 0x2A	; 42
 784:	90 e0       	ldi	r25, 0x00	; 0
 786:	2a e2       	ldi	r18, 0x2A	; 42
 788:	30 e0       	ldi	r19, 0x00	; 0
 78a:	f9 01       	movw	r30, r18
 78c:	20 81       	ld	r18, Z
 78e:	28 60       	ori	r18, 0x08	; 8
 790:	fc 01       	movw	r30, r24
 792:	20 83       	st	Z, r18
        /* Set frame format: 8data, 1stop bit */
        UCSRC = (1<<URSEL) |(3<<UCSZ0);
 794:	80 e4       	ldi	r24, 0x40	; 64
 796:	90 e0       	ldi	r25, 0x00	; 0
 798:	26 e8       	ldi	r18, 0x86	; 134
 79a:	fc 01       	movw	r30, r24
 79c:	20 83       	st	Z, r18
        
        uart_puts("uart init done..." _CR);
 79e:	8b e6       	ldi	r24, 0x6B	; 107
 7a0:	91 e0       	ldi	r25, 0x01	; 1
 7a2:	1e d0       	rcall	.+60     	; 0x7e0 <uart_puts>
}
 7a4:	0f 90       	pop	r0
 7a6:	df 91       	pop	r29
 7a8:	cf 91       	pop	r28
 7aa:	08 95       	ret

000007ac <uart_putc>:
* /return   none
*
*
************************************************************************/
void uart_putc(unsigned char data) 
{    
 7ac:	cf 93       	push	r28
 7ae:	df 93       	push	r29
 7b0:	1f 92       	push	r1
 7b2:	cd b7       	in	r28, 0x3d	; 61
 7b4:	de b7       	in	r29, 0x3e	; 62
 7b6:	89 83       	std	Y+1, r24	; 0x01
    /* Wait for empty transmit buffer */
    while ( !( UCSRA & (1<<UDRE)) )
 7b8:	00 00       	nop
 7ba:	8b e2       	ldi	r24, 0x2B	; 43
 7bc:	90 e0       	ldi	r25, 0x00	; 0
 7be:	fc 01       	movw	r30, r24
 7c0:	80 81       	ld	r24, Z
 7c2:	88 2f       	mov	r24, r24
 7c4:	90 e0       	ldi	r25, 0x00	; 0
 7c6:	80 72       	andi	r24, 0x20	; 32
 7c8:	99 27       	eor	r25, r25
 7ca:	00 97       	sbiw	r24, 0x00	; 0
 7cc:	b1 f3       	breq	.-20     	; 0x7ba <uart_putc+0xe>
    ;
    /* Put data into buffer, sends the data */
    UDR = data;
 7ce:	8c e2       	ldi	r24, 0x2C	; 44
 7d0:	90 e0       	ldi	r25, 0x00	; 0
 7d2:	29 81       	ldd	r18, Y+1	; 0x01
 7d4:	fc 01       	movw	r30, r24
 7d6:	20 83       	st	Z, r18
}
 7d8:	0f 90       	pop	r0
 7da:	df 91       	pop	r29
 7dc:	cf 91       	pop	r28
 7de:	08 95       	ret

000007e0 <uart_puts>:
*
* /example    uart_puts("Test");
*
************************************************************************/
void uart_puts (const char *s)
{
 7e0:	cf 93       	push	r28
 7e2:	df 93       	push	r29
 7e4:	00 d0       	rcall	.+0      	; 0x7e6 <uart_puts+0x6>
 7e6:	cd b7       	in	r28, 0x3d	; 61
 7e8:	de b7       	in	r29, 0x3e	; 62
 7ea:	9a 83       	std	Y+2, r25	; 0x02
 7ec:	89 83       	std	Y+1, r24	; 0x01
    do
    {
        uart_putc (*s);
 7ee:	89 81       	ldd	r24, Y+1	; 0x01
 7f0:	9a 81       	ldd	r25, Y+2	; 0x02
 7f2:	fc 01       	movw	r30, r24
 7f4:	80 81       	ld	r24, Z
 7f6:	da df       	rcall	.-76     	; 0x7ac <uart_putc>
    }
    while (*s++);
 7f8:	89 81       	ldd	r24, Y+1	; 0x01
 7fa:	9a 81       	ldd	r25, Y+2	; 0x02
 7fc:	fc 01       	movw	r30, r24
 7fe:	80 81       	ld	r24, Z
 800:	21 e0       	ldi	r18, 0x01	; 1
 802:	88 23       	and	r24, r24
 804:	09 f4       	brne	.+2      	; 0x808 <uart_puts+0x28>
 806:	20 e0       	ldi	r18, 0x00	; 0
 808:	89 81       	ldd	r24, Y+1	; 0x01
 80a:	9a 81       	ldd	r25, Y+2	; 0x02
 80c:	01 96       	adiw	r24, 0x01	; 1
 80e:	9a 83       	std	Y+2, r25	; 0x02
 810:	89 83       	std	Y+1, r24	; 0x01
 812:	22 23       	and	r18, r18
 814:	61 f7       	brne	.-40     	; 0x7ee <uart_puts+0xe>
}
 816:	0f 90       	pop	r0
 818:	0f 90       	pop	r0
 81a:	df 91       	pop	r29
 81c:	cf 91       	pop	r28
 81e:	08 95       	ret

00000820 <uart_puti>:
*
*           uart_puti(i);
*
************************************************************************/
void uart_puti( uint16_t data )
{
 820:	cf 93       	push	r28
 822:	df 93       	push	r29
 824:	cd b7       	in	r28, 0x3d	; 61
 826:	de b7       	in	r29, 0x3e	; 62
 828:	28 97       	sbiw	r28, 0x08	; 8
 82a:	0f b6       	in	r0, 0x3f	; 63
 82c:	f8 94       	cli
 82e:	de bf       	out	0x3e, r29	; 62
 830:	0f be       	out	0x3f, r0	; 63
 832:	cd bf       	out	0x3d, r28	; 61
 834:	98 87       	std	Y+8, r25	; 0x08
 836:	8f 83       	std	Y+7, r24	; 0x07
    char buffer[6];
    itoa(data, buffer, 10);
 838:	8f 81       	ldd	r24, Y+7	; 0x07
 83a:	98 85       	ldd	r25, Y+8	; 0x08
 83c:	4a e0       	ldi	r20, 0x0A	; 10
 83e:	50 e0       	ldi	r21, 0x00	; 0
 840:	9e 01       	movw	r18, r28
 842:	2f 5f       	subi	r18, 0xFF	; 255
 844:	3f 4f       	sbci	r19, 0xFF	; 255
 846:	b9 01       	movw	r22, r18
 848:	0c d0       	rcall	.+24     	; 0x862 <itoa>
    uart_puts(buffer);
 84a:	ce 01       	movw	r24, r28
 84c:	01 96       	adiw	r24, 0x01	; 1
 84e:	c8 df       	rcall	.-112    	; 0x7e0 <uart_puts>
}
 850:	28 96       	adiw	r28, 0x08	; 8
 852:	0f b6       	in	r0, 0x3f	; 63
 854:	f8 94       	cli
 856:	de bf       	out	0x3e, r29	; 62
 858:	0f be       	out	0x3f, r0	; 63
 85a:	cd bf       	out	0x3d, r28	; 61
 85c:	df 91       	pop	r29
 85e:	cf 91       	pop	r28
 860:	08 95       	ret

00000862 <itoa>:
 862:	fb 01       	movw	r30, r22
 864:	9f 01       	movw	r18, r30
 866:	e8 94       	clt
 868:	42 30       	cpi	r20, 0x02	; 2
 86a:	bc f0       	brlt	.+46     	; 0x89a <itoa+0x38>
 86c:	45 32       	cpi	r20, 0x25	; 37
 86e:	ac f4       	brge	.+42     	; 0x89a <itoa+0x38>
 870:	4a 30       	cpi	r20, 0x0A	; 10
 872:	29 f4       	brne	.+10     	; 0x87e <itoa+0x1c>
 874:	97 fb       	bst	r25, 7
 876:	1e f4       	brtc	.+6      	; 0x87e <itoa+0x1c>
 878:	90 95       	com	r25
 87a:	81 95       	neg	r24
 87c:	9f 4f       	sbci	r25, 0xFF	; 255
 87e:	64 2f       	mov	r22, r20
 880:	77 27       	eor	r23, r23
 882:	1e d0       	rcall	.+60     	; 0x8c0 <__udivmodhi4>
 884:	80 5d       	subi	r24, 0xD0	; 208
 886:	8a 33       	cpi	r24, 0x3A	; 58
 888:	0c f0       	brlt	.+2      	; 0x88c <itoa+0x2a>
 88a:	89 5d       	subi	r24, 0xD9	; 217
 88c:	81 93       	st	Z+, r24
 88e:	cb 01       	movw	r24, r22
 890:	00 97       	sbiw	r24, 0x00	; 0
 892:	a9 f7       	brne	.-22     	; 0x87e <itoa+0x1c>
 894:	16 f4       	brtc	.+4      	; 0x89a <itoa+0x38>
 896:	5d e2       	ldi	r21, 0x2D	; 45
 898:	51 93       	st	Z+, r21
 89a:	10 82       	st	Z, r1
 89c:	c9 01       	movw	r24, r18
 89e:	00 c0       	rjmp	.+0      	; 0x8a0 <strrev>

000008a0 <strrev>:
 8a0:	dc 01       	movw	r26, r24
 8a2:	fc 01       	movw	r30, r24
 8a4:	67 2f       	mov	r22, r23
 8a6:	71 91       	ld	r23, Z+
 8a8:	77 23       	and	r23, r23
 8aa:	e1 f7       	brne	.-8      	; 0x8a4 <strrev+0x4>
 8ac:	32 97       	sbiw	r30, 0x02	; 2
 8ae:	04 c0       	rjmp	.+8      	; 0x8b8 <strrev+0x18>
 8b0:	7c 91       	ld	r23, X
 8b2:	6d 93       	st	X+, r22
 8b4:	70 83       	st	Z, r23
 8b6:	62 91       	ld	r22, -Z
 8b8:	ae 17       	cp	r26, r30
 8ba:	bf 07       	cpc	r27, r31
 8bc:	c8 f3       	brcs	.-14     	; 0x8b0 <strrev+0x10>
 8be:	08 95       	ret

000008c0 <__udivmodhi4>:
 8c0:	aa 1b       	sub	r26, r26
 8c2:	bb 1b       	sub	r27, r27
 8c4:	51 e1       	ldi	r21, 0x11	; 17
 8c6:	07 c0       	rjmp	.+14     	; 0x8d6 <__udivmodhi4_ep>

000008c8 <__udivmodhi4_loop>:
 8c8:	aa 1f       	adc	r26, r26
 8ca:	bb 1f       	adc	r27, r27
 8cc:	a6 17       	cp	r26, r22
 8ce:	b7 07       	cpc	r27, r23
 8d0:	10 f0       	brcs	.+4      	; 0x8d6 <__udivmodhi4_ep>
 8d2:	a6 1b       	sub	r26, r22
 8d4:	b7 0b       	sbc	r27, r23

000008d6 <__udivmodhi4_ep>:
 8d6:	88 1f       	adc	r24, r24
 8d8:	99 1f       	adc	r25, r25
 8da:	5a 95       	dec	r21
 8dc:	a9 f7       	brne	.-22     	; 0x8c8 <__udivmodhi4_loop>
 8de:	80 95       	com	r24
 8e0:	90 95       	com	r25
 8e2:	bc 01       	movw	r22, r24
 8e4:	cd 01       	movw	r24, r26
 8e6:	08 95       	ret

000008e8 <_exit>:
 8e8:	f8 94       	cli

000008ea <__stop_program>:
 8ea:	ff cf       	rjmp	.-2      	; 0x8ea <__stop_program>
